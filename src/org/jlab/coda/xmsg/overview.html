<html>
 <body>
  xMsg is a lightweight, yet full featured publish/subscribe messaging system,
  presenting asynchronous publish/subscribe inter-process communication
  protocol: an API layer in Java, Python and C++.
  <p>
  xMsg provides in memory registration database that is used to register xMsg
  actors (i.e. publishers and subscribers). Hence, xMsg API includes methods
  for registering and discovering publishers and subscribers. This makes xMsg a
  suitable framework to build symmetric SOA based applications. For example a
  services that has a message to publishing can check to see if there are
  enough subscribers of this particular message type.
  <p>
  To solve dynamic discovery problem in pub/sub environment the need of a proxy
  server is unavoidable. xMsg is using 0MQ socket libraries and borrows 0MQ
  proxy, which is a simple stateless message switch to address mentioned
  dynamic discovery problem.
  <p>
  xMsg stores proxy connection objects internally in a connection pool for
  efficiency reasons. To avoid proxy connection concurrency, thus achieving
  maximum performance, connection objects are not shared between threads. Each
  xMsg actor tread will reuse an available connection object, or create a new
  proxy connection if it is not available in the pool.
  <p>
  xMsg publisher can send a message of any topic. xMsg subscribers subscribe
  to abstract topic and provide callbacks to handle messages as they arrive,
  in a so called subscribe-and-forget mode. Neither publisher nor subscriber
  knows of each others existence. Thus publishers and subscribers are
  completely independent of each others. Yet, for a proper communication they
  need to establish some kind of relationship or binding, and that binding is
  the communication or message topic. Note that multiple xMsg actors can
  communicate without interfering with each other via simple {@code "topic"}
  naming conventions. xMsg topic convention defines 3 parts: <i>domain</i>,
  <i>subject</i> and <i>type</i>, presented by the {@link
  org.jlab.coda.xmsg.core.xMsgTopic} class.
  <p>
  xMsg subscriber callbacks (implementing {@link
  org.jlab.coda.xmsg.core.xMsgCallBack} interface) will run in a separate
  thread. For that reason xMsg provides a thread pool, simplifying the job of a
  user. Note that user provided callback routines must be thread safe and/or
  thread enabled.
  <p>
  In a conclusion we present the xMsg entire API
  <ul>
    <li> {@link org.jlab.coda.xmsg.core.xMsg#getConnection      getConnection} <small>(overloaded)</small>
    <li> {@link org.jlab.coda.xmsg.core.xMsg#destroyConnection  destroyConnection}
    <li> {@link org.jlab.coda.xmsg.core.xMsg#publish      publish}
    <li> {@link org.jlab.coda.xmsg.core.xMsg#syncPublish  syncPublish}
    <li> {@link org.jlab.coda.xmsg.core.xMsg#subscribe    subscribe}
    <li> {@link org.jlab.coda.xmsg.core.xMsg#unsubscribe  unsubscribe}
    <li> {@link org.jlab.coda.xmsg.core.xMsg#register     register} <small>(overloaded)</small>
    <li> {@link org.jlab.coda.xmsg.core.xMsg#deregister   deregister} <small>(overloaded)</small>
    <li> {@link org.jlab.coda.xmsg.core.xMsg#discover     discover} <small>(overloaded)</small>
  </ul>
  <p>
  For assistance contact authors:
  <table>
    <tr>
      <td>Vardan Gyurjyan</td>
      <td>{@literal <gurjyan@jlab.org>}</td>
    </tr>
    <tr>
      <td>Sebastián Mancilla</td>
      <td>{@literal <smancill@jlab.org>}</td>
    </tr>
    <tr>
      <td>Ricardo Oyarzún</td>
      <td>{@literal <oyarzun@jlab.org>}</td>
    </tr>
  </table>
  <p>
  Enjoy...
 </body>
</html>
