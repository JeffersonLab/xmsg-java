plugins {
    id 'java'
    id 'maven'
    id 'com.google.protobuf' version '0.8.1'

    id 'checkstyle'
    id 'findbugs'

    id 'eclipse'
    id 'idea'
}


group = 'org.jlab.coda'
archivesBaseName = 'xmsg'
version = '2.4-SNAPSHOT'

defaultTasks 'build'

compileJava {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
}

protobuf {
    protoc {
        artifact = 'com.google.protobuf:protoc:2.6.1'
    }
}

if (hasProperty('protocPath')) {
    protobuf {
        protoc {
            path = protocPath
        }
    }
}

ext {
    generatedProtoDir = "${buildDir.name}/generated/source/proto/main/java"
}


sourceSets {
    main {
        proto {
            srcDir 'src'
        }
        java {
            srcDir 'src'
        }
    }
    test {
        java {
            srcDir 'test'
        }
    }
}


repositories {
    mavenCentral()
}


dependencies {
    compile 'org.zeromq:jeromq:0.3.6'
    compile 'com.google.protobuf:protobuf-java:2.6.1'
    compile 'net.sf.jopt-simple:jopt-simple:4.9'
    testCompile 'junit:junit:4.12'
    testCompile 'org.hamcrest:hamcrest-library:1.3'
    testCompile 'org.mockito:mockito-core:1.10.19'
}


javadoc {
    options.overview = 'src/org/jlab/coda/xmsg/overview.html'
    options.charSet = 'utf8'
    options.encoding = 'utf8'
    options.docEncoding = 'utf8'

    exclude "org/jlab/coda/xmsg/examples/**"
    exclude "org/jlab/coda/xmsg/net/*Factory.java"
    exclude "org/jlab/coda/xmsg/sys/*/*.java"
}

task javadocJar(type: Jar) {
    classifier = 'javadoc'
    from javadoc
}


task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allJava
    from generatedProtoDir
}


artifacts {
    archives javadocJar
    archives sourcesJar
}


if (!hasProperty('localPublicationRepo')) {
    ext.localPublicationRepo = 'file://localhost/tmp/repo'
}

uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: localPublicationRepo)
        }
    }
}


test {
    testLogging {
        exceptionFormat = 'full'
    }
    useJUnit {
        excludeCategories 'org.jlab.coda.xmsg.testing.IntegrationTest'
    }
}


task integrationTest(type: Test) {
    useJUnit {
        includeCategories 'org.jlab.coda.xmsg.testing.IntegrationTest'
    }
    testLogging {
        showStandardStreams = true
        events 'started', 'passed', 'failed'
    }
    outputs.upToDateWhen { false }
}



def deploySpec = copySpec {
    into ('lib') {
        from configurations.runtime
        from jar.archivePath
    }

    from ('scripts/unix') {
        include 'jx_*'
        into 'bin'
        fileMode 0755
    }
}


task deploy(type: Copy, overwrite: true, dependsOn: install) {
    def dest = "$System.env.CLARA_HOME"

    into dest
    with deploySpec

    doFirst {
        if (dest == 'null') {
            throw new GradleException('CLARA_HOME not set')
        }
    }
}



ext.classPathCache = file("${buildDir}/tmp/classpath")
ext.testClassPathCache = file("${buildDir}/tmp/test_classpath")

task cacheClasspath {
    doLast {
        if (!classPathCache.isFile()) {
            classPathCache.parentFile.mkdirs()
            classPathCache.createNewFile()
        }
        classPathCache.write sourceSets.main.runtimeClasspath.asPath
        testClassPathCache.write sourceSets.test.runtimeClasspath.asPath
    }
}
cacheClasspath.inputs.files sourceSets.main.runtimeClasspath
cacheClasspath.inputs.files sourceSets.test.runtimeClasspath
cacheClasspath.outputs.files classPathCache
cacheClasspath.outputs.files testClassPathCache

task printClasspath {
    doLast {
        println classPathCache.text
    }
}

build.dependsOn cacheClasspath
printClasspath.dependsOn cacheClasspath


def ciMode() {
    if (hasProperty("ciMode")) {
        return ciMode.toBoolean()
    }
    return false
}


checkstyle {
    toolVersion = '8.0'
    configFile = file('config/quality/checkstyle.xml')
    configProperties['samedir'] = file('config/quality')
}

findbugs {
    toolVersion = '3.0.1'
    ignoreFailures = true
    effort = 'max'
    reportLevel = 'medium'
    excludeFilter = file('config/quality/findbugs-exclude.xml')
}

tasks.withType(FindBugs) {
    def useXml = ciMode()
    reports {
        xml.enabled = useXml
        html.enabled = !xml.enabled
    }
}

// Marker task to enable findbugs.
task findbugs(
    group: 'Verification',
    description: 'Marker task to enabled findbugs.'
)

task checkFindBugsResults {
    doLast {
        def bugsFound = 0
        [findbugsMain, findbugsTest].forEach {
            bugsFound += printFindBugs it.reports.xml.destination
        }
        if (bugsFound > 0) {
            throw new GradleException("$bugsFound FindBugs rule violations were found.")
        }
    }
}

def printFindBugs(File xml) {
    def slurped = new XmlSlurper().parse(xml)
    def bugs = slurped.BugInstance

    bugs.each { bug ->
        def line = bug.SourceLine
        logger.error "[FindBugs] ${line.@sourcepath}:${line.@start}:${line.@end} [${bug.@type}]"
    }
    bugs.size()
}

if (ciMode()) {
    checkFindBugsResults.mustRunAfter findbugsMain, findbugsTest
    check.dependsOn checkFindBugsResults
}

gradle.taskGraph.whenReady { taskGraph ->
    tasks.findbugsMain.onlyIf {
        taskGraph.hasTask((tasks.findbugs))
    }
    tasks.findbugsTest.onlyIf {
        taskGraph.hasTask((tasks.findbugs))
    }
    tasks.checkFindBugsResults.onlyIf {
        taskGraph.hasTask((tasks.findbugs))
    }
}



eclipse {
    classpath {
        file {
            whenMerged {
                cp -> cp.entries.add(new org.gradle.plugins.ide.eclipse.model.SourceFolder(generatedProtoDir, null))
            }
            withXml { xml ->
                xml.asNode().find {
                    it.@kind == 'src' && it.@path == generatedProtoDir
                }
                .appendNode('attributes')
                .appendNode('attribute', [name:'ignore_optional_problems', value:'true'])
            }
        }
        defaultOutputDir = file("${buildDir}/eclipse-classes")
    }
}

idea {
    module {
        sourceDirs += file(generatedProtoDir)
        excludeDirs -= buildDir
        buildDir.listFiles({d,f->f != 'generated'} as FilenameFilter).each {excludeDirs += it}
    }
}

task checkOutputProtoDir {
    doLast {
        def gsd = file(generatedProtoDir)
        if (!gsd.exists()) {
            gsd.mkdirs()
        }
    }
}

tasks.idea.dependsOn(checkOutputProtoDir)
