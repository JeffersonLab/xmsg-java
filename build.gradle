apply plugin: 'java'
apply plugin: 'maven'
apply plugin: 'com.google.protobuf'

apply plugin: 'checkstyle'
apply plugin: "findbugs"

apply plugin: 'eclipse'
apply plugin: 'idea'


group = 'org.jlab.coda'
archivesBaseName = 'xmsg'
version = '2.3-SNAPSHOT'

defaultTasks 'build'

compileJava {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
}


buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.google.protobuf:protobuf-gradle-plugin:0.7.3'
    }
}

protobuf {
  protoc {
    artifact = 'com.google.protobuf:protoc:2.6.1'
  }
}


sourceSets {
    main {
        proto {
            srcDir 'src/org/jlab/coda/xmsg/data'
        }
        java {
            srcDir 'src'
        }
    }
    test {
        java {
            srcDir 'test'
        }
    }
}


repositories {
    mavenCentral()
}


dependencies {
    compile 'org.zeromq:jeromq:0.3.5'
    compile 'com.google.protobuf:protobuf-java:2.6.1'
    compile 'net.sf.jopt-simple:jopt-simple:4.9'
    testCompile 'junit:junit:4.11'
    testCompile 'org.hamcrest:hamcrest-library:1.3'
    testCompile "org.mockito:mockito-core:1.+"
}


javadoc {
    options.overview = "src/org/jlab/coda/xmsg/overview.html"
    options.charSet = "utf8"
    options.encoding = "utf8"
    options.docEncoding = "utf8"
    options.links("http://docs.oracle.com/javase/8/docs/api/")
    exclude 'org/jlab/coda/xmsg/examples/**'
    exclude 'org/jlab/coda/xmsg/xsys/regdis/**'
}

task javadocJar(type: Jar) {
    classifier = 'javadoc'
    from javadoc
}

if (JavaVersion.current().isJava8Compatible()) {
    allprojects {
        tasks.withType(Javadoc) {
            options.addStringOption('Xdoclint:none', '-quiet')
        }
    }
}


task sourcesJar(type: Jar, dependsOn:classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}


artifacts {
    archives javadocJar
    archives sourcesJar
}


if (!project.hasProperty("localPublicationRepo")) {
    ext.localPublicationRepo = "file://localhost/tmp/repo"
}

uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: localPublicationRepo)
        }
    }
}



test {
    useJUnit {
        excludeCategories 'org.jlab.coda.xmsg.testing.IntegrationTest'
    }
}


task integrationTest(type: Test) {
    useJUnit {
        includeCategories 'org.jlab.coda.xmsg.testing.IntegrationTest'
    }
    outputs.upToDateWhen { false }
}



def deploySpec = copySpec {
    into ('lib') {
        from configurations.runtime
        from "${jar.archivePath}"
    }

    from ("${project.rootDir}/scripts/unix") {
        include "jx_*"
        into 'bin'
        fileMode 0755
    }
}


task deploy(type: Copy, overwrite: true, dependsOn: install) {
    def dest = "$System.env.CLARA_HOME"
    def dir = new File(dest)
    into dir
    with deploySpec

    doFirst {
        if (dest == "null") {
            throw new GradleException('CLARA_HOME not set')
        }
        dir.mkdirs()
    }
}



task(startRegistrar, dependsOn: 'classes', type: JavaExec) {
    main = 'org.jlab.coda.xmsg.xsys.xMsgRegistrar'
    if (project.hasProperty("regArgs")) {
        args Eval.me(regArgs)
    }
    classpath = sourceSets.main.runtimeClasspath
}

task(startProxy, dependsOn: 'classes', type: JavaExec) {
    main = 'org.jlab.coda.xmsg.xsys.xMsgProxy'
    if (project.hasProperty("proxyArgs")) {
        args Eval.me(proxyArgs)
    }
    classpath = sourceSets.main.runtimeClasspath
}


task(runPub, dependsOn: 'classes', type: JavaExec) {
    main = 'org.jlab.coda.xmsg.examples.Publisher'
    if (project.hasProperty("pubArgs")) {
        args Eval.me(pubArgs)
    }
    classpath = sourceSets.main.runtimeClasspath
}

task(runSyncPub, dependsOn: 'classes', type: JavaExec) {
    main = 'org.jlab.coda.xmsg.examples.SyncPublisher'
    classpath = sourceSets.main.runtimeClasspath
}

task(runSub, dependsOn: 'classes', type: JavaExec) {
    main = 'org.jlab.coda.xmsg.examples.Subscriber'
    classpath = sourceSets.main.runtimeClasspath
}



task(localThr, dependsOn: 'classes', type: JavaExec) {
    main = 'perf.LocalThroughput'
    if (project.hasProperty("locThrArgs")) {
        args Eval.me(locThrArgs)
    }
    classpath = sourceSets.test.runtimeClasspath
}

task(remoteThr, dependsOn: 'classes', type: JavaExec) {
    main = 'perf.RemoteThroughput'
    if (project.hasProperty("remThrArgs")) {
        args Eval.me(remThrArgs)
    }
    classpath = sourceSets.test.runtimeClasspath
}


task printClasspath << {
    println sourceSets.test.runtimeClasspath.asPath
}



checkstyle {
    toolVersion = "6.14"
    configFile = new File(rootDir, "config/quality/checkstyle.xml")
}

findbugs {
    toolVersion = "3.0.1"
    ignoreFailures = true
    effort = "default"
    reportLevel = "medium"
    excludeFilter = new File(rootDir, "config/quality/findbugs-exclude.xml")
}

task checkstyleHtml << {
    ant.xslt(in: checkstyleMain.reports.xml.destination,
             style: new File(rootDir, 'config/quality/checkstyle-noframes-sorted.xsl'),
             out: new File(checkstyleMain.reports.xml.destination.parent, 'main.html'))
}

checkstyleMain.finalizedBy checkstyleHtml

tasks.withType(FindBugs) {
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

// Marker task to enable findbugs.
task findbugs(
    group: "Verification",
    description: "Marker task to enabled findbugs."
)

gradle.taskGraph.whenReady { taskGraph ->
    tasks.findbugsMain.onlyIf {
        taskGraph.hasTask((tasks.findbugs))
    }
    tasks.findbugsTest.onlyIf {
        taskGraph.hasTask((tasks.findbugs))
    }
}



def buildDirName = buildDir.name
def generatedProtoDir = "${buildDirName}/generated/source/proto/main/java"

eclipse {
    classpath {
        file {
            whenMerged {
                cp -> cp.entries.add(new org.gradle.plugins.ide.eclipse.model.SourceFolder(generatedProtoDir, null) )
            }
            withXml { xml ->
                xml.asNode().find {
                    it.@kind == 'src' && it.@path == generatedProtoDir
                }
                .appendNode('attributes')
                .appendNode('attribute', [ name:'ignore_optional_problems', value:"true"])
            }
        }
        defaultOutputDir = file("${buildDir}/eclipse-classes")
    }
}

idea {
    module {
        sourceDirs += file(generatedProtoDir)
        excludeDirs -= buildDir
        buildDir.listFiles({d,f->f != 'generated'} as FilenameFilter).each {excludeDirs += it}
    }
}

task checkOutputProtoDir << {
    def gsd = file(generatedProtoDir)
    if (!gsd.exists()) {
        gsd.mkdirs()
    }
}

tasks.idea.dependsOn(checkOutputProtoDir)
