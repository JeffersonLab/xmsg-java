/*
 * Copyright (C) 2017. Jefferson Lab (JLAB). All Rights Reserved.
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for governmental use, educational, research, and not-for-profit
 * purposes, without fee and without a signed licensing agreement.
 *
 * IN NO EVENT SHALL JLAB BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
 * INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF
 * THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF JLAB HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * JLAB SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE. THE CLARA SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
 * HEREUNDER IS PROVIDED "AS IS". JLAB HAS NO OBLIGATION TO PROVIDE MAINTENANCE,
 * SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 * This software was developed under the United States Government License.
 * For more information contact author at gurjyan@jlab.org
 * Department of Experimental Nuclear Physics, Jefferson Lab.
 */

plugins {
    id 'java-library'
    id 'maven-publish'
    id 'com.google.protobuf' version '0.9.4'

    id 'checkstyle'
    id 'com.github.spotbugs' version '5.2.5'

    id 'eclipse'
    id 'idea'
    id 'com.github.johnrengelman.shadow' version '8.1.0'
}

group = 'org.jlab.coda'
version = '2.4-SNAPSHOT'

defaultTasks 'build'

sourceSets {
    main {
        proto {
            srcDir 'src'
        }
        java {
            srcDir 'src'
        }
    }
    test {
        java {
            srcDir 'test'
        }
    }
}

repositories {
    mavenCentral()
}

dependencies {
    api 'org.zeromq:jeromq:0.4.3'
    api 'com.google.protobuf:protobuf-java:4.28.2'
    implementation 'net.sf.jopt-simple:jopt-simple:5.0.4'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.5.0'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher:1.5.0'
    testImplementation 'org.hamcrest:hamcrest-library:2.1'
    testImplementation 'org.mockito:mockito-core:2.28.2'
}

java {
    withSourcesJar()
    withJavadocJar()

    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17
}

ext {
    generatedProtoDir = "${buildDir.name}/generated/source/proto/main/java"
}

protobuf {
    protoc {
        artifact = 'com.google.protobuf:protoc:4.28.2'
        if (project.hasProperty('protocPath')) {
            path = protocPath
        }
    }
    generateProtoTasks {
        all().each { task ->
            task.builtins {
                java {
                    option 'lite'
                }
            }
        }
    }
}

tasks.withType(JavaCompile) {
    if (JavaVersion.current() > JavaVersion.VERSION_1_8) {
        options.release = 8
    }
}

javadoc {
    options.overview = 'src/org/jlab/coda/xmsg/overview.html'
    options.charSet = 'utf8'
    options.encoding = 'utf8'
    options.docEncoding = 'utf8'
    options.addStringOption('Xdoclint:none', '-quiet')

    exclude "org/jlab/coda/xmsg/examples/**"
    exclude "org/jlab/coda/xmsg/net/*Factory.java"
    exclude "org/jlab/coda/xmsg/sys/*/*.java"
}


// ✅ configure fat jar with NO classifier
shadowJar {
    archiveClassifier.set('') // ← this makes it replace the default jar
    archiveVersion.set('')    // optional: remove version in filename
}

// ✅ publish ONLY the fat jar as main artifact
publishing {
    publications {
        maven(MavenPublication) {
            artifact(shadowJar) // ← no {} block, no classifier, just this
        }
    }
}
//publishing {
//    publications {
//        maven(MavenPublication) {
//            from components.java
//        }
//    }
//}

build.dependsOn shadowJar

// creating a uber jar, including all dependencies
//shadowJar {
//    archiveBaseName.set('xmsg-2.4')
//    archiveClassifier.set('')
//    archiveVersion.set('')
//}


test {
    useJUnitPlatform {
        excludeTags 'integration'
    }
    testLogging {
        exceptionFormat = 'full'
    }
}

tasks.register('integrationTest', Test) {
    useJUnitPlatform {
        includeTags 'integration'
    }
    testLogging {
        showStandardStreams = true
        events 'started', 'passed', 'failed'
    }
    testClassesDirs = testing.suites.test.sources.output.classesDirs
    classpath = testing.suites.test.sources.runtimeClasspath
    outputs.upToDateWhen { false }
}

//////////////////////////////////////////////////////////////////////////////
// deployment
//////////////////////////////////////////////////////////////////////////////

def deploySpec = copySpec {
    into ('lib') {
        from configurations.runtimeClasspath
        from jar
    }

    from ('scripts/unix') {
        include 'jx_*'
        into 'bin'
        fileMode 0755
    }
}

tasks.register('deploy', Copy) {
    def dest = "$System.env.CLARA_HOME"

    into dest
    with deploySpec

    doFirst {
        if (dest == 'null') {
            throw new GradleException('CLARA_HOME not set')
        }
    }

    dependsOn publishToMavenLocal
}

//////////////////////////////////////////////////////////////////////////////
// development scripts
//////////////////////////////////////////////////////////////////////////////

ext {
    classPathCache = file("${buildDir}/tmp/classpath")
    testClassPathCache = file("${buildDir}/tmp/test_classpath")
}

tasks.register('cacheClasspath') {
    inputs.files sourceSets.main.runtimeClasspath
    inputs.files sourceSets.test.runtimeClasspath
    outputs.files classPathCache
    outputs.files testClassPathCache
    doLast {
        classPathCache.write sourceSets.main.runtimeClasspath.asPath
        testClassPathCache.write sourceSets.test.runtimeClasspath.asPath
    }
}

tasks.register('printClasspath') {
    doLast {
        println classPathCache.text.replace(':', '\n')
    }
    dependsOn cacheClasspath
}


assemble.dependsOn cacheClasspath

//////////////////////////////////////////////////////////////////////////////
// quality check
//////////////////////////////////////////////////////////////////////////////

ext {
    ciMode = properties['ciMode'] ?: 'false'
}

checkstyle {
    toolVersion = '8.22'
    configFile = file('config/quality/checkstyle.xml')
    configProperties['samedir'] = file('config/quality')
}

spotbugs {
    toolVersion = '4.8.3'
    ignoreFailures = true
    effort = 'max'
    reportLevel = 'medium'
    excludeFilter = file('config/quality/findbugs-exclude.xml')
}

tasks.withType(com.github.spotbugs.snom.SpotBugsTask) {
    def useXml = ciMode.toBoolean()
    reports {
        xml.enabled = useXml
        html.enabled = !useXml
    }
}

tasks.register('checkSpotBugsResults') {
    doLast {
        def bugsFound = 0
        [spotbugsMain, spotbugsTest].each {
            try {
                bugsFound += printSpotBugs it.reports.getByName('xml').destination
            } catch (FileNotFoundException e) {
                logger.info e.message
            }
        }
        if (bugsFound > 0) {
            throw new GradleException("$bugsFound SpotBugs rule violations were found.")
        }
    }
}

def printSpotBugs(File xml) {
    def slurped = new XmlSlurper().parse(xml)
    def bugs = slurped.BugInstance
    bugs.each { bug ->
        def line = bug.SourceLine
        logger.error "[SpotBugs] ${line.@sourcepath}:${line.@start}:${line.@end} [${bug.@type}]"
    }
    bugs.size()
}

tasks.register('spotbugs') {
    group = 'Verification'
    description = 'Marker task to enable SpotBugs.'

    mustRunAfter spotbugsMain, spotbugsTest
    if (ciMode.toBoolean()) {
        finalizedBy checkSpotBugsResults
    }
}

gradle.taskGraph.whenReady { taskGraph ->
    tasks.spotbugsMain.onlyIf {
        taskGraph.hasTask(tasks.spotbugs)
    }
    tasks.spotbugsTest.onlyIf {
        taskGraph.hasTask(tasks.spotbugs)
    }
    tasks.checkSpotBugsResults.onlyIf {
        taskGraph.hasTask(tasks.spotbugs)
    }
}

//////////////////////////////////////////////////////////////////////////////
// IDE configuration
//////////////////////////////////////////////////////////////////////////////

eclipse {
    classpath {
        file {
            defaultOutputDir = file("${buildDir}/eclipse")
            whenMerged { classpath ->
                classpath.entries.each { source ->
                    if (source.kind == 'src' && source.hasProperty('output')) {
                        source.output = "${buildDir.getName()}/eclipse"
                    }
                }
                classpath.entries.add(new org.gradle.plugins.ide.eclipse.model.SourceFolder(generatedProtoDir, null))
            }
            withXml { xml ->
                xml.asNode().find {
                    it.@kind == 'src' && it.@path == generatedProtoDir
                }
                .appendNode('attributes')
                .appendNode('attribute', [name:'ignore_optional_problems', value:'true'])
            }
        }
    }
}

idea {
    module {
        sourceDirs += file(generatedProtoDir)
        excludeDirs -= buildDir
        buildDir.listFiles({d,f->f != 'generated'} as FilenameFilter).each {excludeDirs += it}
    }
}

task checkOutputProtoDir {
    doLast {
        def gsd = file(generatedProtoDir)
        if (!gsd.exists()) {
            gsd.mkdirs()
        }
    }
}

tasks.idea.dependsOn(checkOutputProtoDir)
